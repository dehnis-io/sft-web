Discussing the process of this devOps life circle

== This is a portfolio website and the stacks used to devosify this project are 
1. Terraform - for building up the infrastructure as code -- on minikube
- Create a dockerfile to push an image of the project to the docker registry 
2. Github action - for continue integration 
3. Helm - as a package manager for our orchestration tool = kubernetes 
4. Argocd - for continue delivery 

Note: We'll not be using ingress for this project, so we use port forwarding to server our application to the web browser
= Note: Docker should be installed on your machine as we'll configure terraform to set up minikube on the machine using docker as the driver 

======= Terraform ==========
Search for the procedure to install terraform on your machine.

- In the project directory, create a folder call - terraform-config . The folder will contain 3 files, main.tf, provider.tf, backend.tf, variable.tf

1. main.tf       - holds instructions for the base infrastructure resource

2. provider.tf   - Here we'll define the resource for the kubenetes. This will let terraform interact with the kubernetes provider. This provider resource will pull connections details directory from the minikube cluster resource, allowing terraform to manage kubernetes resources within minikube. Thus the kubernetes provider configuration depends on the attributes from the minikube cluster resource.
Here the configuration sets up the kubernetes provider to authenticate against a minikube cluster using client certificate authentication. 

### Terraform needs a way to store the resources it manages and it does this using a state file. In a production environment, it will typically be stored in a remote backend like S3 or Azure blob storage. For the sake of this project, we'll use a local n=back end. So we will configure this in the backend.tf file.

3. backend.tf    - holds he backend storage

4. variable.tf   - hold any useful varibales

= Now do
- terraform init
- terraform plan 
- terraform apply 


### create a .gitignore file and add
.terraform/
*.tfstate
*.tfstate.*
terraform-config/minikube-linux-amd64


===== Dockerfile ======
In the root directory, create a docker file using nginx alpine as the base because we'll be using nginx web client server to server the website to the browser.


===== Github action =====
Next - is to automate building and pushing the docker image to the docker registry using github action pipelines.
In the root directory create a .github folder and inside it create another folder called workflows:
mkdir -p .github/workflows
cd into the .github >> workflows and create a file called ci.yaml - touch ci.yaml

In the ci.yaml file, we will write the pipeline for the continue integration of our project 

## go setup secrets for login into your docker registry to enable github access the docker registry and push the image
On the github, while in the project repository, click on the settings option at the right side of the page and scroll on the left nav to secrets and variables >> actions  
Click on new repository secret - enter name for the secret, say: 

DOCKER_USERNAME = type in the value of your docker registry username and add 
DOCKER_TOKEN = login to your docker >> go to account settings>> personal access token then generate a new token, go back to github and add the token  

== Also for the git-action to be able to automatically push new commit or update, we need to pass a token from github. So in you profile settings, go and generate a token and then in the repo, go to the secret and variable section again and add a secret variable form github, 


===== Helm =====
Now, lets set up helm to manage our kubernetes deployments. 
Helm is a package manager for Kubernetes that uses a packaging format called charts. Charts are collections of files that describe a related set of Kubernetes resources. Helm simplifies deploying and managing kubernetes resources across clusters.
Install heml on your machine  - 
So on the terminal while in the project root directory do - helm create projectName-helm-chart

In the text editor, open the values.yaml file in the project helm chart.

Basic helm chart archi:
sft-web/                 <-- Helm chart root folder
├─ Chart.yaml            <-- chart metadata (your snippet goes here)
├─ values.yaml           <-- default values
└─ templates/            <-- k8s manifests rendered from templates
   ├─ deployment.yaml
   ├─ service.yaml
   └─ ingress.yaml

We will write out helm instructions in the values.yaml file


###### Let's go update the ci.yaml file the .github folder 
We'll use the linux (sed) command to find the tag line in the values.yml file and replace the tag with the latest
image ID generated in the git-action pipeline using the git SHA

Set Git author 


====== ArgoCD =====
Let's set up argocd for continue delivery of our code update. This ensue that any modification made to 
the application code is replaced to kubernetes which is serving the application to the web/ users
Argocd does this by monitoring the githb reprository for any update. When it detects a change in the helm chart
Argocd automatically synchronizes the kubernetes cluster to match current state of the application.

We'll use the terraform to get argocd deployed using helm.
We'll set this up in our terraform provider.tf file 




