Discussing the process of this devOps life circle

== This is a portfolio website and the stacks used to devosify this project are 
1. Terraform - for building up the infrastructure as code -- on minikube
- Create a dockerfile to push an image of the project to the docker registry 
2. Github action - for continue integration 
3. Helm - as a package manager for our orchestration tool = kubernetes 
4. Argocd - for continue delivery 

Note: We'll not be using ingress for this project, so we use port forwarding to server our application to the web browser
= Note: Docker should be installed on your machine as we'll configure terraform to set up minikube on the machine using docker as the driver 

======= Terraform ==========
Search for the procedure to install terraform on your machine.

- In the project directory, create a folder call - terraform-config . The folder will contain 3 files, main.tf, provider.tf, backend.tf, variable.tf

1. main.tf       - holds instructions for the base infrastructure resource

2. provider.tf   - Here we'll define the resource for the kubenetes. This will let terraform interact with the kubernetes provider. This provider resource will pull connections details directory from the minikube cluster resource, allowing terraform to manage kubernetes resources within minikube. Thus the kubernetes provider configuration depends on the attributes from the minikube cluster resource.
Here the configuration sets up the kubernetes provider to authenticate against a minikube cluster using client certificate authentication. 

### Terraform needs a way to store the resources it manages and it does this using a state file. In a production environment, it will typically be stored in a remote backend like S3 or Azure blob storage. For the sake of this project, we'll use a local n=back end. So we will configure this in the backend.tf file.

3. backend.tf    - holds he backend storage

4. variable.tf   - hold any useful varibales

= Now do
- terraform init
- terraform plan 
- terraform apply 


### create a .gitignore file and add
.terraform/
*.tfstate
*.tfstate.*
terraform-config/minikube-linux-amd64


===== Dockerfile ======
In the root directory, create a docker file using nginx alpine as the base because we'll be using nginx web client server to server the website to the browser.


===== Github action =====
Next - is to automate building and pushing the docker image to the docker registry using github action pipelines.
In the root directory create a .github folder and inside it create another folder called workflows:
mkdir -p .github/workflows
cd into the .github >> workflows and create a file called ci.yaml - touch ci.yaml

In the ci.yaml file, we will write the pipeline for the continue integration of our project 

## go setup secrets for login into your docker registry to enable github access the docker registry and push the image
On the github, while in the project repository, click on the settings option at the right side of the page and scroll on the left nav to secrets and variables >> actions  
Click on new repository secret - enter name for the secret, say: 

DOCKER_USERNAME = type in the value of your docker registry username and add 
DOCKER_TOKEN = login to your docker >> go to account settings>> personal access token then generate a new token, go back to github and add the token  

== Also for the git-action to be able to automatically push new commit or update, we need to pass a token from github. So in you profile settings, go and generate a token and then in the repo, go to the secret and variable section again and add a secret variable form github, 


===== Helm =====
Now, lets set up helm to manage our kubernetes deployments. 
Helm is a package manager for Kubernetes that uses a packaging format called charts. Charts are collections of files that describe a related set of Kubernetes resources. Helm simplifies deploying and managing kubernetes resources across clusters.
Install heml on your machine  - 
So on the terminal while in the project root directory do - helm create projectName-helm-chart

In the text editor, open the values.yaml file in the project helm chart.

Basic helm chart archi:
sft-web/                 <-- Helm chart root folder
├─ Chart.yaml            <-- chart metadata (your snippet goes here)
├─ values.yaml           <-- default values
└─ templates/            <-- k8s manifests rendered from templates
   ├─ deployment.yaml
   ├─ service.yaml
   └─ ingress.yaml

Define custom manifest entries for deployment and service manifest in the project helm chart - template folder
We will write out helm instructions in the values.yaml file

Created _helpers.tpl in the template folder as well and wrote some instructions 


###### Let's go update the ci.yaml file the .github folder 
We'll use the linux (sed) command to find the tag line in the values.yml file and replace the tag with the latest
image ID generated in the git-action pipeline using the git SHA

Set Git author 


====== ArgoCD =====
Let's set up argocd for continue delivery of our code update. This ensue that any modification made to 
the application code is replaced to kubernetes which is serving the application to the web/ users
Argocd does this by monitoring the githb reprository for any update. When it detects a change in the helm chart
Argocd automatically synchronizes the kubernetes cluster to match current state of the application.

We'll use the terraform to get argocd deployed using helm.
We'll set this up in our terraform provider.tf file - set kubenetes config path for helm 
Add a new file call argocd.tf in the terraform-config file.

## Note ###
The helm release instruction in the teraform argocd config file wil install argocd directly into our 
minikube cluster in argocd namespace as defined.
Afterward run 
- terraform init
- terraform plan 
- terraform apply 

If successful, confirm the argocd resources:
kubectl get namespace
kubectl get all -n argocd

To access the argocd locally=, we'll do the kubectl port forward with the argocd service name: 
kubectl get svc -n argocd
kubectl port-forward svc/argocd-server -n argocd 8081:443

The port-forward command basically forwards traffic from the locally machine to argocd server in the 
minikube cluster
On web browser, go to localhost:8081

the initial username to login to argoocd - admin
To get the initial passowrd - kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath="{.data.password}" | base64 -d 

##### Using argocd cli 
since we will be using argocd cli to tell argocd which git repositiry to monitor and define the path
to our helm chart and the desired namespace in kubernetes
Let create argocd application file:
In the project root directory, create - argocd-app.yaml 
==define the instructions

#### install argocd cli on your machine then login to argocd using your termnail 
argocd login localhost:8081 --username admin --password <the_decoded_password> --insecure

#### Note - Head tp github and create an acess token to be added to argocd as a repository credential - to enable argocd to access the githuuub repository 
and monitor the heml chart. The access token will allow argocd to authenticate for read only purposes

On github - head to your profile >> settings >> developer settings >> personal access token then click on Token (classic)
Crreate new token (classic) - 
Give it a name, token TTL duration and check on repo
Grab the generated token and do this in your terminal 

argocd repo add <project_github_repo_url> --username <github_username> --password "<github_access_token>" --server localhost:8081 --insecure

To access the argocd UI - 
kubectl port-forward svc/argocd-server -n argocd <port>:443
kubectl port-forward svc/argocd-server -n argocd 8081:443

= localhost:8081

After writing manifest for argocd 
kubectl apply -f argocd-app.yaml

## note ## 
we are using the --secure flag to tell argocd to skid TLS verification. This is just for development environment for this project
but for production envronemnt it is not recommended, it is best to use a trusted certificate

On the projject repo - go to settings >> actions >> general >> scroll to work flow permission check the read and write permissions radio button and save.

-- commit and push changes
-- confirm that CI works fine 
-- confirm that argocd works fine 
-- confirm that pods and service are created 

kubectl get --all-namespaces
kubectl get pods
kubectl get svc

kubectl port-forward svc/<project-service-name> 8181:80

= localhost:8181
Viola!!!
